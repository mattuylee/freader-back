# freader

**目录**

- [路由](#%E8%B7%AF%E7%94%B1)
- [验证](#%E9%AA%8C%E8%AF%81)
  - [身份验证](#%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81)
  - [请求参数验证](#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81)
- [统一响应](#%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94)
- [测试](#%E6%B5%8B%E8%AF%95)


## 路由
<a id="route"></a>
路由配置改由配置文件式的方式配置，避免写大量重复代码的枯燥。但路由配置仍是程序的一部分，而非真正的配置文件（如[测试配置](#test)），因此它们被定义在.js文件中而不是.json文件。

路由配置的结构如下：
```
controller          // controller
    route1          // 路由
        request1    // 相同路由下的不同请求方法
            param1  // 请求参数
            param2  // 请求参数
```
每一层次的详细结构定义见[src/domain/types/route.d.ts](./src/domain/types/route.d.ts)

每一个Controller**应该**对应一个路由配置文件，它们调用同一个service的不同方法。  
但例外是被允许的，可以通过RequestMethod#invoke属性为每个请求方法单独设置要调用的service层方法，这将允许使用除Controller#service属性指定的service之外的方法，但你**必须**指定方法调用时的*this*指向谁，通过RequestMethod#thisObject指定，否则将使用controller.service。


## 验证
来自用户的数据总是不被信任的。验证必不可少。

### 身份验证
通过在请求头中包含一个token来认证身份。但登录和注册请求除外。  
token的值是随机生成的，每次登录后它的值将会改变。同时用户的token也可以作为注册时的邀请码，新用户成功注册后邀请码对应的用户的token将会重新生成，即原邀请码失效。  
如果在请求过程中token变化或验证失败，会在响应体中要求变更token或重新登录，方式见[统一响应](#u-response)。

### 请求参数验证
请求参数的合法性也需要验证。  
过滤不合法的参数有利于减少服务器的不必要开销，如连接数据库等。另外，mongodb的使用也要求我们对参数进行验证。

试想，注册请求要求前端传递一个json对象，它包含用户信息。当我们对用户信息相关的字段验证通过后，它似乎没问题。但如果它包含一大堆无效字段呢，我们就可能向数据库插入大量垃圾数据。  
这样的验证可以有很多方法，但我认为零碎的把验证代码分布在各个地方显得冗余，因此将其集成在了路由参数配置里：这样我就可以通过类似配置文件的方法来对数据进行验证，而无需在业务逻辑中包含额外的验证代码。关于验证的代码在[这里](./src/util/validator.ts)。


## 统一响应
<a id="u-response"></a>
为了一致性和方便，任何请求的响应体都具有统一的结构，并且HTTP状态码总是200。
```
{
    code        //错误代码，一般为对应的HTTP状态码。但并不保证设置值。为0的时候等同于200
    error       //错误内容
    data        //请求的响应内容
    needLogin   //是否要求重新登录（当前会话已过期）
    token       //如果非空，即要求变更会话ID（token）
}
```

## 测试
<a id="test"></a>
参考路由配置，测试和配置路由一样，可能需要写很多重复代码，因此同样的，我将测试工作交给了配置文件。我只需要在配置文件中配置对应路由的请求参数，便可以自动化的执行测试。  
考虑到配置文件不在代码范畴内，而是根据情况随时改动，测试的配置文件格式并不像路由配置一样严格，它更加自由。测试配置文件参考[配置文件](./test/test-config-default.json)。
